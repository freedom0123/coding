---
description: MySQL 中的各种锁
---

# 锁

## 一、概述



mysql 将 锁进行了分类，提供了两种标准的行级别的锁：

+ **共享锁**：简称 S锁。在事务要读取一条记录的时候，需要先获取该记录的S锁
+ **独占锁**：简称 X锁。在事务要改动一条记录的时候，需要先获取该记录的X锁。

::: info
其中，只有 S 锁和 S 锁是兼容的，其余情况都不兼容，也就是说，如果一个事务获取到了某行记录的 S 锁，其余事务也只能获取到这行事务的 S 锁，只能进行读取。

:::

读取一条记录的时候，为了保证不同的情况之下，加不同的锁，mysql 提供的如下的两种方式。

```sql
-- 给读取的数据加 S锁
select... lock in share mode;

-- 给读取的数据加 X锁
select... for update;
```

对于写操作，针对于不同的操作，也是不同的

+ `delete 操作`：获取 X 锁
+ `update 操作`：如果说修改完成之中的数据行，存储空间未发生变化，X 锁，如果存储空间发生了变化，其实就是先执行 delete，后执行 insert，加锁规则和 delete 和 insert 一致。
+ `insert 操作`：一般情况之下，新插入一条记录并不会加锁

上面讨论的锁，都是基于一条记录的，也称之为行级锁，加锁之后影响的也仅仅是一行记录而已。同样可以对表进行加锁。加入写锁，实际上就是在修改表的结构。

当我们对于表级别加入读锁的时候，实际上要保证没有行级别的写锁。对表级别加入写锁的时候，要保证没有行级别的读锁和写锁。

但是，加表级别的锁的时候，怎么快速判断有没有锁呢？他并没有采用遍历的方式，看一下每行记录的状态，而是，重新提出来一个概念，意向锁。

+ 意向共享锁：IS 锁，当事务给某个记录加入 S 锁的时候，首先加一个表级别的 IS 锁
+ 意向独占锁：IX 锁，当事务给某个记录加入 X 锁的时候，首先加一个表级别的 IX 锁。

## 二、MySQL 中的锁
MySQL 中的锁，按照锁的粒度分，分为一下三类：

+ 全局锁：锁定数据库中的所有表
+ 表级锁：每次操作锁住整张表
+ 行级锁：每次操作锁住对应的行数据

### 2.1  全局锁
全局锁就是对整个数据库实例加锁，加锁之后整个实例就处于只读状态，已经更新操作的事务提交语句都将会被阻塞。

其典型的使用场景就是对**全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，从而保证数据的完整性。**

客户端连接断开，会自动释放全局锁

```sql
-- 加锁
flush tables with read lock;

-- 解锁
unlock tables;
```

### 2.2  表级锁
对于我们执行 select，update 等行操作的时候，InnoDB 存储引擎并不会为这个表添加表级别的 S 锁或者 X 锁。只有当我们执行 DDL 语句的时候，才会添加上对应的锁，会阻塞对应的 select，update 等语句，这个过程实在 server 层通过 **元数据锁（MDL**）来实现的。加锁过程是由系统自动控制，无需显示使用，在访问一张表的时候会自动加上，在事务提交之后进行释放，这就意味着在事务执行过程中，都是持有MDL锁的，主要是防止用户在进行CRUD操作的时候，其他线程对表结构进行改变。

:::tips
<font style="color:rgb(44, 62, 80);">申请 MDL 锁的操作会形成一个队列，队列中</font>**<font style="color:rgb(48, 79, 254);">写锁获取优先级高于读锁</font>**<font style="color:rgb(44, 62, 80);">，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</font>

<font style="color:rgb(44, 62, 80);">所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更</font>

:::

我们也可以通过如下的方式，获取**表级别的 S 锁 和 X 锁**。

1. S 锁
+ 加锁：`lock tables 表名 read`
+ 解锁：`unlock tables`
+ 其他客户端能够进行读，但是写操作会被阻塞
2. X 锁
+ 加锁：`lock tables 表名 write;`
+ 解锁：`unlock tables;`
+ 其他客户端的读和写都是处于阻塞状态

同样，在上文之中也提到了，在对某行记录做操作的时候，会在表级别上挂一个**意向锁**。用来快速判断，表中的行记录有没有被加锁。

在为某个字段声明 `AUTO_INCREMENT` 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 `AUTO-INC` 锁实现的。在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉

### 2.3 行级锁
行级锁，也称之为记录锁，就是在记录上加的锁。锁定粒度最小，发生锁冲突的概率最低，并发度最高，应用于InnoDB存储引擎。是通过对索引上的索引项加锁来实现的。在 MySQL 之中有提供了如下几种行锁：

1. Record Locks：记录锁，仅仅把一条记录锁住，它也是分为读锁和写锁之分的。
2. Gap Locks：只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
    - 间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
    - 不允许其他事务往这条记录前边的间隙插入新记录
    - GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况
3. Next-Key Locks：锁住一个范围，并且锁住记录本身，行锁+间隙锁。当查询的索引含有唯一的属性的时候，InnoDB 之中会将锁降级为行锁。
4. 插入意向锁：在一个事务插入一条记录的时候，要判断一下插入的位置是否被加了 Gap 锁，如果说有的话，我们就需要进行等待，此时也会在内存之中生成一个对应的锁结构，将 is_waiting 设置为 false，等其他的的事务提交之后，间隙锁释放，这些阻塞的 insert 语句，就会继续执行，这样的锁，称之为插入意向锁。
