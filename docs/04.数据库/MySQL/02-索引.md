---
title: 索引
description: MySQL 索引使用及原理
date: 2025-01-12
tag:
- MySQL
---

# 索引

##     一、基本信息

在 MySQL 之中，以 页 作为内存和磁盘之间的交互单位，在每一个数据页之中，会按照   **按照主键的大小进行排序，组成一个单链表**，为了加快在一个数据页之中，数据查找的效率，InnoDB 使用了页目录，将记录进行分组，并将分组之后的组内最大元素的偏移量，记录在页目录之中，这样，我们在通过主键查找数据的时候，就能够首先在页目录之中，定位到具体的槽，进而确定到分组，分组确定之后，在分组之中，进行遍历，就能够查找到对应的元素。

但是，如何在多个数据页之中进行查找？多个数据页是通过 File Header 进行串联的，构成一个双向链表，貌似，我们只能通过遍历的方式，确定一下，元素在那个数据页之中，然后在通过上述的方式，进行数据页内查找。

但是，如何定位页呢？我们开始尝试对这些数据页也添加一个目录，如下图

![](asserts/1726495004304-71957b20-9902-4e79-a43e-f5232bd9b0f7.png)

建立出来这样的目录结果之后，通过主键搜索时，我们可以首先在目录项里面查找，确定一下，数据在那个数据页之中，也就是找到大于等于当前搜索的主键的最小主键在哪个目录项里面。找到了目录项就找到了数据页。这个目录就叫做 **索引**。

:::info
 不过有一个前提条件，前一个页中主键的最大值是小于后一个页中主键的最小值。

:::

在上图之中，我们的目录项都是连续进行存储的， InnoDB 中页的大小为 16KB，一个数据页对应一个目录项，随着数据页增多，目录项也就变多，在一个数据页中放下这些目录项就很难了，并且如果说将一个数据页中的数据全部进行删除，就需要将目录项整体移动。

为了解决这个问题，复用了存储用户记录的数据页来存储目录项，并且通过记录头中的信息`record_type`的取值来用户记录和这些目录项记录。如果是 `1就是目录项记录，0为普通用户记录，2为最小记录，3为最大记录`。我们就来把上面的这个图来完善一下：

![](asserts/1726495459954-83588f86-9d4b-43b1-8189-4533db5af807.png)

如果说目录项所在的数据页超过了页的容量，就需要分配一个新的数据页来存储这个目录项，层层抽取。我们最终形成的树结果如图所示

![](asserts/1726496195883-2c12f874-fee6-428c-a256-e675e64ea88d.png)

这样的数据结构，称之为 B+ 树。在 InnoDB 中，每个节点都是数据页，**但是只有叶子节点才会真正的存储用户的完整数据，其余节点都是存储的目录**。我们同样将这样的数据结构，称之为索引。

在上文之中，我们也提到了，后一个页的最小主键，必须小于前一个的最大主键，这样才能够建立出目录结构，形成索引。这样的结果，实际上 InnoDB 在创建表的时候，会自动进行创建，称之为，**聚簇索引**。并且搜索条件是主键的时候，才能发挥作用。而如果搜索条件不是主键的时候，并不能使用。

但是实际场景之中，我们并不能保证，都只通过主键来查询数据，为了解决这一问题，我们可以多建立几颗 B+ 树，不同的B+树采取不同的排序规则，在叶子节点中存放的不在是实际的数据，而是 **主键 + 索引列**，这种 B+ 树我们就称之为 **二级索引或者辅助索引**。

![](asserts/1726544884344-4fa5da53-cb73-49bd-b1e7-b3648235ba55.png)

使用这种方式，我们需要先根据规则找到主键值，然后通过主键值进行一次聚簇索引的查找，这个操作叫做 **回表**。有时候为了避免回表带来的性能消耗，在 select 查询的时候，尽量查询索引列，也就是说索引 k 已经“覆盖了”我们的查询需求，我们称为 **覆盖索引。**我们也可以为多个列建立一个索引，称之为 **联合索引**，但本质仍然是二级索引。如果说创建联合索引的顺序为 `a,b,c`，则B+树的数据页和记录先按照`a列`的值进行排序，在`a列`的值相同的情况之下才使用`b列`，依次类推。比如下面这样，如果第一列 相同了，在按照第二列来进行排序。

![](asserts/1726544884344-4fa5da53-cb73-49bd-b1e7-b3648235ba55.png)

通过使用索引，能够提高数据检索的效率，降低数据库的 IO 成本，但是，维护索引结构也同样需要占用空间，但是如果需要移除或者更新表中的数据，也同样需要维护这部分数据结构。

## 二、操作索引
接下来，我们就来实际操作一下索引：

```sql
-- 创建表的时候添加索引
create table users (
    id int not null,
    name varchar(30),
    sex varchar(10),
    key MyIndex (name)
);

-- 添加索引
alter table users add key idx_name (name);

-- 添加联合索引
alter table users add key index_name_sex(name,sex);

-- 删除索引
alter table users drop key idx_name;
```

数据库会为我们建立一个聚簇索引，并且我们自己创建了一个联合索引

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

## 三、索引的使用
接下来，我们首先创建一个如下的表结构，用来进行测试

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

创建完成之后，我们就来看一下，索引可以应用于哪些场景。在开始之前，我们首先回顾一下，以前的内容

::: info
一个表之中，只有一个聚簇索引，他是通过主键来进行排序的，并且只有搜索条件是主键的时候，才会使用这个索引。而联合索引是在索引结果中记录了索引列和主键值，有多个索引列的时候，会首先按照第一个字段进行排序，第一个字段相同，按照第二个索引列进行排序，以此类推。

:::

下面列举了能够使用索引的场景：

1. **全值匹配**：我们搜索条件中的列和索引列一致，这就称之为全值匹配

```sql
select * from person_info where name = '范亮' and birthday = '1985-06-01' and phone_number = '14538720548'
```

2. **匹配左边的列**
+ 搜索条件中不用包含全部联合索引中的列，只包含左边就行（建立索引时的左边）

```sql
select * from person_info where name = '范亮'
```

+ 匹配多个最左边的列，但是如果说我们想匹配联合索引中多个列的时候，各个列必须是联合索引中最左边连续的列。

```sql
select * from person_info where name = '范亮' and birthday = '1985-06-01'
```

3. **匹配列前缀**
+ 对于字符串类型的索引列来说，我们只匹配他的前缀是可以快速定位记录的。但是如果出现了 `%范`这种就不能够走索引
+ 对于字符串来说的话，在 MySQL 中排序，实际上是字典序

```sql
select * from person_info where name = '范%'
```

4. **匹配范围值**
+ 所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录
    - 语句执行：在二级索引中，找到 name > 'A' 的记录，读取该记录的主键值，然后进行回表操作，获取到记录返回给客户端，这个时候，我们就要开始遍历叶子节点了，一条一条遍历，判断 name 是否是小于 'z'，如果是，读取该主键值，进行回表操作，获取到记录返回给客户端。

+ 不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引
5. **精准匹配某一列并范围匹配另外一列**
6. **用于排序**
+ 在使用联合索引的时候，请注意，order by 的子句后边的列的顺序也必须按照索引列的顺序给出
+ 排序列之中如果包含不在当前索引中的列，不会走索引
7. **用于分组**

## 四、Explatin
一个查询语句经过 MySQL 查询优化器的各种基于成本和规则的优化之后，会生成一个执行计划，他会说明查询语句的执行方式。

```sql
explain select * from person_info where name = '范亮' and birthday = '1985-06-01' and phone_number = '14538720548'
```

执行完成之后，我们就看到了他的执行计划，我们首先对他输出的列来进行说明！

![](asserts/1704456992840-8756afd4-6244-49dd-a7ed-d0aed7ccac4a.png)

上图对应的各个列，对应的解释如下：

![](asserts/1726546948893-ba62ba29-1ed4-4961-8b08-dc6f3782133c.png)

在了解完成 explain 之后，接下来，我们来准备测试环境

```sql
CREATE TABLE s1 (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY 
  (key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;

CREATE TABLE s2 (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;

insert into s1(id,key1,key2,key3) values (1,1,2,3);

insert into s2(id,key1,key2,key3) values (1,1,2,3);
```

### 4.1 table
explain 输出的每条记录都对应某个单表的访问方法，每条记录的 table 列表示该表的表名

1）单表查询

```sql
mysql> explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

2）多表查询

```sql
mysql> explain select * from s1 inner join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
2 rows in set, 1 warning (0.00 sec)
```

不过对于 union 查询来讲，table 不仅仅是我们在 select 语句之中写到的 表名，而是多出了一个，出现这样的原因在于，union 查询，是将两个表里面的数据查询出来之后合并一下，进行去重的，这个时候 MySQL 会使用内部的临时表，所以 table 就是 <union1,2>

```sql
mysql> explain select * from s1 union select * from s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

不过，有一点值得注意的是：如果使用 union all，就不会使用临时表，主要原因在于 union 要对结果集进行去重。

```sql
mysql> explain select * from s1 union all select * from s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
2 rows in set, 1 warning (0.03 sec)
```

### 4.2 id
查询语句中每出现一个 SELECT 关键字，就会为它分配一个唯一的 id 值，也就是执行计划里面的 id 列。即时 from 后面有多张表，但是这些记录的 id 列都是相同的，出现在前面的是驱动表，出现在后面的被驱动表

```sql
mysql> explain select * from s1 inner join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+
2 rows in set, 1 warning (0.00 sec)
```

不过，在 union 查询之中，id 列会出现 null 的情况，为了看得方便，我们还是把刚才那一条语句拿过来

```sql
mysql> explain select * from s1 union select * from s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

union 查询，会使用内部表，id 为 null，表示这个临时表是为了合并两个查询的结果集而创建的

### 4.3 select_type
每一个 SELECT 关键字代表的小查询都定义了一个称之为 `select_type` 的属性，意思就是，我们只要知道了某个小查询的 `select_type` 属性，就知道了这个小查询在整个大查询之中所扮演的角色。

1）`SIMPLE`：查询语句之中不包含 UNION 或者 子查询的查询 都算作是 SIMPLE 类型

```sql
mysql> explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

2）`PRIMARY、union、union_result`：对于包含 union，union_all 或者子查询的大查询来说，它是由几个小查询组成个的，其中最为左边的那个查询的 select_type 的值就是 primary，其余的小查询都是 UNION，选择使用临时表来进行union查询的去重工作，针对临时表的 select_type 就是 union_result

```sql
mysql> explain select * from s1 union select * from s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL            |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

<font style="color:#8A8F8D;">ps：对于《MySQL 是怎样运行的：从根上理解MySQL》之中提到的其余类型，没理解，后面在进行补充吧</font>

### 4.4 type
执行计划的一条记录就代表着 MYSQL 对某个表执行查询的时候的访问方法，其中的 type 列表示这个访问方法是什么。接下来，我们也来看一下，这个 type 列

#### 4.4.1 system
当表中只有一条记录，并且表使用的存储引擎的统计数据是精确的时候，也就说使用 MyISAM 就可以，但是使用 InnoDB 就不可以

```sql
mysql> create table t(i int) Engine=MyISAM;
Query OK, 0 rows affected (0.14 sec)

mysql> insert into t values(1);
Query OK, 1 row affected (0.01 sec)

mysql> explain select * from t;
+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t     | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
```

当我们再次插入一条记录，这个 type 字段已经不是 system 了，而是 all 了

```sql
mysql> insert into t values(2);
Query OK, 1 row affected (0.01 sec)

mysql> explain select * from t;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

#### 4.4.2 const
当我们根据 主**键 或者 唯一二级索引列** 与 **常数** 进行等值匹配。我们表里面有 id = 1 的，但是没有 id = 2，可以实际看一下执行计划的差别

1）主键

```sql
mysql> explain select * from s1 where id = 1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from s1 where id = 2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
1 row in set, 1 warning (0.00 sec
```

2） 唯一二级索引

```sql
mysql> explain select * from s1 where key2 = 2;
+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from s1 where key2 = 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
1 row in set, 1 warning (0.00 sec)
```

#### 4.4.3 eq_ref
在连接查询的时候，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的

```sql
mysql> explain select * from s1 ,s2 where s1.id = s2.id;
+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref           | rows | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL          |    1 |   100.00 | NULL  |
|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | mybatis.s1.id |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)
```

#### 4.4.4 ref
当通过普通的二级索引列与常量进行等值匹配的时候，访问方法可能就是 ref。对于包含多个索引列的二级索引，只要是最左边的连续索引列是与常数的等值匹配就可能采用 ref 的访问方法。

```sql
mysql> explain select * from s1 where key1 in (select key1 from s2 where s2.key1 = s1.key1);
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-----------------------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref             | rows | filtered | Extra                       |
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-----------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL            |    1 |   100.00 | Using where                 |
|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | mybatis.s1.key1 |    1 |   100.00 | Using index; FirstMatch(s1) |
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-----------------------------+
2 rows in set, 2 warnings (0.00 sec)
```

#### 4.4.5 ref_or_null
有时候我们不仅仅需要找到某个二级索引列等于常数的记录，还想把该列的值为 Null 的记录也找出来。

#### 4.4.5 fulltext
全文索引

#### 4.4.6 index_subquery
访问子查询中的表使用的是普通索引

#### 4.4.7 range
使用索引来获取某个范围区间的记录，访问方法可能就是 range

```sql
mysql> explain select * from s1 where id > 2 and id < 5;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

#### 4.4.8 index
使用索引覆盖，但需要扫描全部的索引记录

```sql
mysql> explain select key1 from s1;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

#### 4.4.9 all
全表扫描

```sql
mysql> explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.02 sec)
```

### 4.5 索引失效
1、当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；

2、当我们在查询条件中对索引列使用函数，就会导致索引失效。

3、当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。

4、MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。

5、联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。

6、在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

7、使用`<font style="color:rgb(44, 62, 80);">!=</font>` 或者`<font style="color:rgb(44, 62, 80);"><></font>` ,就会造成索引的失效

## 五、杂谈
### 5.1 索引数据结构

除了，使用 B+ 树作为索引之外，还有以下几种常见的索引结构
1）**哈希表**：将值放在数组中，用一个哈希函数把 key 换算成一个确认的位置，然后把 value 放在数组的这个位置之上

+ <font style="color:rgb(51, 51, 51);">用拉链法处理哈希冲突问题，适用于只有等值查询的场景</font>
+ 模糊查找不支持：哈希表是把索引字段映射成对应的哈希码然后在存放在对应的位置，这样的话，如果我们要进行模糊查找的时候，显然哈希表这种结构不支持，而B+树则可以通过最左前缀匹配原则快速查找
+ 不支持范围查找
+ 哈希冲突问题：索引字段通过哈希映射成哈希码，如果说很多字段都刚好映射到相同值的话，那么形成的哈希结构将会是一条很长的链表，这样的话，查找的时间复杂度就会大大增加

2）**有序数组**：按照顺序存储，查询用二分法可以快速查询，但是更新效率低，只适用于静态存储引擎

对于二叉搜索树，AVL 树，红黑树，通常都是将数据全部加载到内存之中进行处理。由于索引不仅仅是位于内存之中，还需要写入到磁盘之中，当数据量较大时，访问的节点个数就会比较多。从这里，能够看到硬盘的访问次数实际上和树的高度成正比。

![](asserts/1726674002785-e44537e2-0fa7-4831-9580-20014a3dc773.jpeg)

为了降低树的高度，就出现了 B 树。它实际上是一个多叉的平衡搜索树。

![](asserts/1726674033388-fd569287-e9a5-4a8c-b8a2-78ff01bf0e30.jpeg)

对于一个 B 树，他有以下几个特点：

1. 平衡，所有的叶子节点都是在同一层
2. 有序：节点内有序，任意元素的左子树都小于他，右子树都是大于他
3. 多路：对于 m 阶的 B 树
    1. 最多有 m 个分支，m - 1 个元素
    2. 最少
        1. 根节点：2 个分支，1 个元素
        2. 其余节点：（m / 2 向上取整）个分支，（m / 2 向上取整）- 1 个元素

插入元素的步骤：

1. 先查找到插入的位置进行插入
2. 如果没有上溢出，无需调整
3. 否则中间元素  （m / 2 向上取整） 位元素 上移，两边分裂，直到没有上溢出为止

![](asserts/1726674060997-0ce65f6e-74a9-447c-885c-891e8ac3c5bb.jpeg)

B树的能做的功能，B+树都能够做；B+树的中间节点不保存数据，能够存放更多的节点数据， B树不管是叶子节点还是非叶子节点，都会保存数据，只能增加树的高度，导致IO操作变多，查询的性能变低

### 创建好的索引
1. <font style="color:rgb(51, 51, 51);">只为出现在 where 子句之中的列，连接子句中的连接列，或者出现在 order by 或者 group by 子句之中的列创建索引</font>
2. <font style="color:rgb(51, 51, 51);">为列的基数大的列创建索引</font>
3. <font style="color:rgb(51, 51, 51);">索引列的类型尽量小</font>
4. <font style="color:rgb(51, 51, 51);">可以只对字符串值的前缀建立索引</font>
5. <font style="color:rgb(51, 51, 51);">只有索引列在比较表达式中单独出现才可以适用索引</font>
6. <font style="color:rgb(51, 51, 51);">为了尽可能少的让</font>**<font style="color:#2F54EB;background-color:rgb(255, 245, 245);">聚簇索引</font>**<font style="color:rgb(51, 51, 51);">发生页面分裂和记录移位的情况，建议让主键拥有</font>**<font style="color:#2F54EB;background-color:rgb(255, 245, 245);">AUTO_INCREMENT</font>**<font style="color:rgb(51, 51, 51);">属性。</font>
7. <font style="color:rgb(51, 51, 51);">定位并删除表中的重复和冗余索引</font>
8. <font style="color:rgb(51, 51, 51);">尽量使用</font>**<font style="color:#2F54EB;background-color:rgb(255, 245, 245);">覆盖索引</font>**<font style="color:rgb(51, 51, 51);">进行查询，避免</font>**<font style="color:#2F54EB;background-color:rgb(255, 245, 245);">回表</font>**<font style="color:rgb(51, 51, 51);">带来的性能损耗。</font>

