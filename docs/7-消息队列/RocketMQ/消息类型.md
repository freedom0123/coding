#  消息类型

在 RocketMQ 5.x 版本中，一个核心的架构改进是**对 Topic 进行消息类型的强约束**。这意味着，**一个 Topic 在创建时就必须指定其承载的消息类型**，并且只能接收该类型的消息。这种设计带来了更好的性能、更清晰的语义和更简便的运维管理。

按照消息的类型不同，分为了普通消息（Normal），延迟消息（Delay），顺序消息（FIFO），事务消息（TRANSACTION）。

我们可以在创建 Topic 的时候就制定对应 `message.type`（以普通消息为例）

```sh
./mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t coding -a +message.type=NORMAL
```

接下来，我们就来看一下这几种消息类型

## 一、普通消息

普通消息，是 RocketMQ 中最基本的消息，没有任何的功能的特性。适用于对消息的使用时机，处理顺序没有严格要求的场景

发送示例如下：

```java
@Resource
private RocketMQClientTemplate rocketMQClientTemplate;

@Test
void test_sendNormalMessage() {
    SendReceipt sendReceipt = rocketMQClientTemplate.syncSendNormalMessage("spring-boot-normal-topic", "hello rocketmq");
    log.info("sendReceipt:{}", sendReceipt);
}
```

## 二、延迟消息

延迟消息，可以在发送到 RocketMQ 之中**指定时间后**才能被消费者消费。指定的时间不能够超过 24 小时。

创建延迟消息的队列示例如下：

```sh
./mqadmin updateTopic -c DefaultCluster -n 192.168.5.5:9876 -t coding-delay -a +message.type=DELAY
```

在 SpringBoot 中可以通过如下方式发送

```java
@Resource
private RocketMQClientTemplate rocketMQClientTemplate;

@Test
public void test_sendDelayMessage() {
    final String topic = "coding-delay";
    String sendMessage = "hello, coding-delay topic";
    MessageBuilderImpl messageBuilder = new MessageBuilderImpl();
    messageBuilder.setKeys(UUID.randomUUID().toString());
    messageBuilder.setTopic(topic);
    messageBuilder.setBody(sendMessage.getBytes(StandardCharsets.UTF_8));
    Message message = messageBuilder.build();
    SendReceipt sendReceipt = rocketMQClientTemplate.syncSendDelayMessage(topic, message, Duration.ofSeconds(10));
}
```

注意，这里传入的是 Duration，在实际传入的时候，会转为对应的时间戳

```java
if (Objects.nonNull(messageDelayTime)) {
    messageBuilder.setDeliveryTimestamp(System.currentTimeMillis() + messageDelayTime.toMillis());
}
```

## 三、顺序消息

顺序消息，支持消费者按照发送者发送的先后顺序进行消费。

在 RocketMQ 中，一个 Topic 由多个队列组成，生产者发送的消息可能被分发到不同队列中。而消费者组内，不同队列可能由不同消费者处理，从而导致消息的顺序性无法保证。

:::info

这种队列机制类似于 Kafka 的分区，而 Kafka 仅能确保单个分区内的消息有序。

在前司中，为解决消息顺序问题，我们采用了多 Topic 的方案：每个 Topic 仅设置一个队列（即单分区），并通过业务 ID 将同一类消息路由到同一个 Topic 中。

这样，单个生产者发送的消息可以保持顺序性，但若有多个生产者并发发送，这样的顺序也是不能够进行保证的。

同时，借助消费者组的特性，每个单队列 Topic 只能被组内的一个消费者消费，从而在消费端也保证了顺序性。不过，这种方案也带来了消费者压力较大的问题，同一个消费者组内的其余消费者，其实就充当了当前消费者的 Salver。

:::

在这里首先创建一个顺序队列：

```sh
./mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t coding-fifo -a +message.type=FIFO
```

发送示例如下：

```java
@Resource
private RocketMQClientTemplate rocketMQClientTemplate;

@Test
void test_send_fifo_message() {
    final String topic = "coding-fifo";
    String message = "hello, coding-fifo topic";
    SendReceipt sendReceipt = rocketMQClientTemplate.syncSendFifoMessage(topic, message, "coding-fifo-group");
    log.info("messageId = {}", sendReceipt.getMessageId());
}
```

在客户端发送消息的 API 中，需要指定 3 个参数，分别是：Topic 的名称，要发送的消息，MessageGroup。其中 MessageGroup 为消息组，RocketMQ 会保证同一个消息组内的消息，按照发送顺序会存储在同一个队列中，这样就能够保证同一组消息，只能够被一个消费者消费，这样也能够一定程度上保证发送的有序性。

在了解了基本使用之后，我们就来实际分析一下 RocketMQ 的实现机制

## 四、事务消息

事务消息，支持在分布式场景下保障消息生产和本地事务的最终一致性。

这里我们首先创建一个 Topic

```sh
./mqadmin updateTopic -c DefaultCluster -n 192.168.5.5:9876 -t coding-transaction -a +message.type=TRANSACTION
```





