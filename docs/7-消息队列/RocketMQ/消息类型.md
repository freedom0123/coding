#  消息类型

在 RocketMQ 5.x 版本中，一个核心的架构改进是**对 Topic 进行消息类型的强约束**。这意味着，**一个 Topic 在创建时就必须指定其承载的消息类型**，并且只能接收该类型的消息。这种设计带来了更好的性能、更清晰的语义和更简便的运维管理。

按照消息的类型不同，分为了普通消息（Normal），延迟消息（Delay），顺序消息（FIFO），事务消息（TRANSACTION）。

我们可以在创建 Topic 的时候就制定对应 `message.type`（以普通消息为例）

```sh
./mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t coding -a +message.type=NORMAL
```

接下来，我们就来看一下这几种消息类型

## 一、普通消息

普通消息，是 RocketMQ 中最基本的消息，没有任何的功能的特性。适用于对消息的使用时机，处理顺序没有严格要求的场景

发送示例如下：

```java
@Resource
private RocketMQClientTemplate rocketMQClientTemplate;

@Test
void test_sendNormalMessage() {
    SendReceipt sendReceipt = rocketMQClientTemplate.syncSendNormalMessage("spring-boot-normal-topic", "hello rocketmq");
    log.info("sendReceipt:{}", sendReceipt);
}
```

## 二、延迟消息

延迟消息，可以在发送到 RocketMQ 之中**指定时间后**才能被消费者消费。指定的时间不能够超过 24 小时。

创建延迟消息的队列示例如下：

```sh
./mqadmin updateTopic -c DefaultCluster -n 192.168.5.5:9876 -t coding-delay -a +message.type=DELAY
```

在 SpringBoot 中可以通过如下方式发送

```java
@Resource
private RocketMQClientTemplate rocketMQClientTemplate;

@Test
public void test_sendDelayMessage() {
    final String topic = "coding-delay";
    String sendMessage = "hello, coding-delay topic";
    MessageBuilderImpl messageBuilder = new MessageBuilderImpl();
    messageBuilder.setKeys(UUID.randomUUID().toString());
    messageBuilder.setTopic(topic);
    messageBuilder.setBody(sendMessage.getBytes(StandardCharsets.UTF_8));
    Message message = messageBuilder.build();
    SendReceipt sendReceipt = rocketMQClientTemplate.syncSendDelayMessage(topic, message, Duration.ofSeconds(10));
}
```

注意，这里传入的是 Duration，在实际传入的时候，会转为对应的时间戳

```java
if (Objects.nonNull(messageDelayTime)) {
    messageBuilder.setDeliveryTimestamp(System.currentTimeMillis() + messageDelayTime.toMillis());
}
```

## 三、顺序消息

顺序消息，支持消费者按照发送者发送的先后顺序进行消费。

在 RocketMQ 中，一个 Topic 由多个队列组成，生产者发送的消息可能被分发到不同队列中。而消费者组内，不同队列可能由不同消费者处理，从而导致消息的顺序性无法保证。

:::info

这种队列机制类似于 Kafka 的分区，而 Kafka 仅能确保单个分区内的消息有序。

在前司中，为解决消息顺序问题，我们采用了多 Topic 的方案：每个 Topic 仅设置一个队列（即单分区），并通过业务 ID 将同一类消息路由到同一个 Topic 中。

这样，单个生产者发送的消息可以保持顺序性，但若有多个生产者并发发送，这样的顺序也是不能够进行保证的。

同时，借助消费者组的特性，每个单队列 Topic 只能被组内的一个消费者消费，从而在消费端也保证了顺序性。不过，这种方案也带来了消费者压力较大的问题，同一个消费者组内的其余消费者，其实就充当了当前消费者的 Salver。

:::

在这里首先创建一个顺序队列：

```sh
./mqadmin updateTopic -c DefaultCluster -n localhost:9876 -t coding-fifo -a +message.type=FIFO
```

发送示例如下：

```java
@Resource
private RocketMQClientTemplate rocketMQClientTemplate;

@Test
void test_send_fifo_message() {
    final String topic = "coding-fifo";
    String message = "hello, coding-fifo topic";
    SendReceipt sendReceipt = rocketMQClientTemplate.syncSendFifoMessage(topic, message, "coding-fifo-group");
    log.info("messageId = {}", sendReceipt.getMessageId());
}
```

在客户端发送消息的 API 中，需要指定 3 个参数，分别是：Topic 的名称，要发送的消息，MessageGroup。其中 MessageGroup 为消息组，RocketMQ 会保证同一个消息组内的消息，按照发送顺序会存储在同一个队列中，这样就能够保证同一组消息，只能够被一个消费者消费，这样也能够一定程度上保证发送的有序性。

在了解了基本使用之后，我们就来实际分析一下 RocketMQ 的实现机制

## 四、事务消息

事务消息，支持在分布式场景下保障消息生产和本地事务的最终一致性。那么 RocketMQ 引入事务消息是为什么？

比如，现有如下的场景，用户注册之后，需要向下游系统发送消息，初始化这个用户需要的资源信息。示例代码如下：

```java
transactionTemplate.executeWithoutResult(transactionStatus -> {
    User user = new User();
    user.setName("coding-transaction");
    userMapper.insert(user);
});
// TODO: 调用 RocketMQ 发送消息
```

此时，用户成功保存，但是 RocketMQ 发送消息发送失败了，就会到导致下游系统没有接受到对应的消息。

那么如果先发送 RocketMQ ，发送成功后再进行本地事务的执行呢？注意，这种方式是不可行的，这样做，就会导致消费者消费到对应的消息了，去数据库加载对应的信息了，但是实际上数据还没进入数据库之中。类似下方代码，此时事务没有提交，消费者消费到消息后，是获取不到 name 为 coding-transaction 的消息的。

```java
transactionTemplate.executeWithoutResult(transactionStatus -> {
    User user = new User();
    user.setName("coding-transaction");
    userMapper.insert(user);
    // TODO: 调用 RocketMQ 发送消息
});
```

所以，为了解决消息发送与数据库事务的不一致性带来的业务出错，RocketMQ 中引入了 事务消息，对应的执行流程如下：

1）发送者发送消息至 RocketMQ，消息处于半提交状态，不能够被消费者消费

2）发送者执行本地的事务，执行完成之后，向 RocketMQ 发送 二次确认 的请求

- 本地事务执行成功，向 RocketMQ 发送 commit  请求，消息可以被消费者消费
- 本地事务执行失败，向 RocketMQ 发送 rollback 请求，消息不会被消费者消费

3）如果 RocketMQ 长时间未收到发送者的 二次确定 的请求，或者收到的二次确认的结果为未知状态，RocketMQ 会任意发送者示例发送消息回查，通过回查的结果，判断当前消息是否可以被消费者消费

接下来，我们看一下具体的使用示例：

这里我们首先创建一个 Topic

```sh
./mqadmin updateTopic -c DefaultCluster -n 192.168.5.5:9876 -t coding-transaction -a +message.type=TRANSACTION
```

这里我们以 SpringBoot 为例

::: code-group

```java [发送者]
public interface Sender {
    /**
     * 发送消息
     * @param topic 要发送的 Topic
     * @param message 发送的消息
     * @param supplier 执行业务操作函数
     * @return RocketMQ 的发送结果
     */
    SendReceipt send(String topic, String message, Supplier<Boolean> supplier) throws ClientException;
}
```

```java [发送者示例]
@Component
@Slf4j
public class TransactionRocketMqSender implements Sender {
    
    @Resource
    private RocketMQClientTemplate rocketMQClientTemplate;

    @Override
    public SendReceipt send(String topic, String message, Supplier<Boolean> supplier) throws ClientException {
        Message<ByteBuffer> sendMessage = MessageBuilder.withPayload(StandardCharsets.UTF_8.encode(message)).build();
        // 1. 调用 RocketMQ 发送消息，此时消息已经发送到了 RocketMQ, 但是还不能够被消费者消费
        Pair<SendReceipt, Transaction> sendReceiptTransactionPair = rocketMQClientTemplate.sendTransactionMessage(topic, sendMessage);
        // 2. 开启事务
        Transaction transaction = sendReceiptTransactionPair.getTransaction();
        try {
            // 3. 执行本地事务
            Boolean locationTransactionRes = supplier.get();
            if (!locationTransactionRes) {
                transaction.rollback();
            }
        } catch (Exception e) {
            log.error("系统异常", e);
            transaction.rollback();
            throw new RuntimeException(e);
        }
        // 4. 提交事务，提交完成后，消息才能够被消费者消费
        transaction.commit();
        return sendReceiptTransactionPair.getSendReceipt();
    }
}
```

```java [测试消息发送]
@SpringBootTest
@Slf4j
public class TestTransactionMessage {

    @Resource
    private TransactionTemplate transactionTemplate;

    @Resource
    private UserMapper userMapper;

    @Resource
    private Sender sender;
    
    @Test
    public void test_send_transaction_message() throws Exception {
        final String topic = "coding-transaction";
        String prepareToSendMessage = "hello, coding-transaction";
        SendReceipt send = sender.send(topic, prepareToSendMessage, () -> {
            try {
                transactionTemplate.executeWithoutResult(transactionStatus -> {
                    User user = new User();
                    user.setName("coding-transaction");
                    userMapper.insert(user);
                });
            } catch (Exception e) {
                log.error("保存用户信息异常", e);
                return false;
            }
            return true;
        });
        log.info("发送结果为：{}", send);
        new CountDownLatch(1).await();
    }
}
```

:::

